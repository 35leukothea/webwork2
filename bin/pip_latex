#!/usr/bin/perl -w
# 
# pip_latex
# 
# Wrapper for latex to use it as a filter.  I would use the ordinary
# pip, but tex has its own pecularities which need their own wrapper.
# 
# Usage:
# 
# % pip_latex [-v [0|1|2]] [-L]
# to read LaTeX source from stdin, write DVI to stdout
# 
# Alternatively, invoke as 'pip_tex' to use as a wrapper for tex.
# 
# This program makes some effort to weed out actual error messages
# from tex's output, but they're not very parseable so it will
# probably miss lots.  There are three ways to deal with errors:
# 
# -v 0        default: only error lines (if any) printed to stderr
# -v 1        if any errors, all of tex's output printed
# -v 2        get the full TeX verbosity every time
# 
# Finding what exactly is an error (rather than just chatter) seems
# very difficult.  So the 'detection' catches only serious errors
# marked with '!', not overfull hboxes and the like.
# 
# The flag -l means that the TeX logfile, rather than its ordinary
# output, will be printed to stdout.  So for example -l -v1 will
# examine tex's ordinary output for 'errors', and if any are found,
# print the logfile to stderr.  (-v0 -l makes no sense.)
# 
# Version 0.1, for pip distribution 0.2.2
# 
# This program is in the public domain.  Use at your own risk.
# <http://www.doc.ic.ac.uk/~epa98/work/apps/pip/>.
# 
# -- Ed Avis, epa98@doc.ic.ac.uk, 2001-01-22
# 

use strict;

my $TEX = ($0 =~ /pip_tex$/i) ? 'tex' : 'latex';
my $TEXPUT='texput';
my $AUX = '.aux';
my $DVI = '.dvi';
my $LOG = '.log';
my $DEV_NULL = '/dev/null';
my $BUFSIZE = 100000;

# Prototypes
sub tmpdir();
sub print_fh($$);
sub is_tex_error($);

use Getopt::Std;
use vars qw[$opt_v $opt_l]; getopts('v:l');
$opt_v = 0 if not defined $opt_v;
if (@ARGV or (defined $opt_v and $opt_v !~ /^[012]$/)) {
    die "usage: $0 [-v [0|1|2]] [-l]";
}

my $dir = tmpdir();
chdir $dir or die "cannot chdir to $dir: $!";

# FIXME: should look at exit status from $TEX.  Could use my_system()
# from the unarc distribution?
# 
open (TEXOUT, "$TEX 2>&1 |")
  or die "cannot run $TEX: $!";

if ($opt_v == 0 and not $opt_l) {
    # Look for errors and print them
    while (<TEXOUT>) {
	print STDERR if is_tex_error($_);
    }
}
elsif ($opt_v == 0 and $opt_l) {
    die '-l makes no sense without -v1 or -v2';
}
elsif ($opt_v == 1 and not $opt_l) {
    # Look for errors, if any then print the entire output
    my $backlog = '';
    while (<TEXOUT>) {
	if (is_tex_error($_)) {
	    # Found an error - print the entire output
	    print STDERR $backlog;
	    print STDERR;
	    print_fh(\*TEXOUT, \*STDERR);
	    last;
	}
	else {
	    $backlog .= $_;
	}
    }
}
elsif ($opt_v == 1 and $opt_l) {
    # Look for errors, if any then print the logfile
    while (<TEXOUT>) {
	if (is_tex_error($_)) {
	    open (LOG, "$TEXPUT$LOG")
	      or die "cannot open $TEXPUT$LOG in $dir: $!";
	    print_fh(\*LOG, \*STDERR);
	    last;
	}
    }
}
elsif ($opt_v == 2 and not $opt_l) {
    # Show all of tex's stdout
    print_fh(\*TEXOUT, \*STDERR);
}
elsif ($opt_v == 2 and $opt_l) {
    # Read all of tex's output so it finishes
    read(TEXOUT, $_, $BUFSIZE)
      until eof TEXOUT;

    # Show the logfile
    open (LOG, "$TEXPUT$LOG")
      or die "cannot open $TEXPUT$LOG in $dir: $!";
    print_fh(\*LOG, \*STDERR);
}
else { die }

# Print DVI to stdout, if there is one
if (open (DVI, "$TEXPUT$DVI")) {
    print_fh(\*DVI, \*STDOUT);
}
else {
    warn "cannot open $TEXPUT$DVI in $dir: $!, producing no output";
}

# Clean up.  For some reason tex sometimes creates files named '.dvi'
# etc.
# 
foreach ($LOG, $AUX, $DVI) {
    (not -f) or unlink or die "cannot unlink $_ from $dir: $!";
    $_ = "$TEXPUT$_";
    (not -f) or unlink or die "cannot unlink $_ from $dir: $!";
}

foreach (<*>, <.*>) {
    next if $_ eq '.' or $_ eq '..';
    warn "found unexpected output file $_ in $dir";
    unlink or die "cannot unlink $_ from $dir: $!";
}

chdir '..' or die "cannot chdir to .. from $dir: $!";
rmdir $dir or die "cannot rmdir $dir: $!";


# tmpdir()
# 
# Create a temporary directory and return its name.
# 
sub tmpdir() {
    die 'usage: tmpdir()' if @_;

    my $tmp;
    foreach (@ENV{qw[TMP TMPDIR TEMP]},
	     '/tmp', '/usr/tmp', '/var/tmp', '/temp' )
    {
	if (defined and -d and -r and -w and -x) {
	    $tmp = $_;
	    last;
	}
    }

    my $r = "$tmp/$$";

    # FIXME: This may be a security hole?
    warn "stale $r exists, trying to reuse" if -e $r;

    mkdir $r, 0700 or die "cannot mkdir $r: $!";
    return $r;
}


# print_fh()
# 
# Read all the characters left in a filehandle and print them to
# another filehandle.
# 
# Parameters:
#   filehandle to read from (ref to filehandle glob)
#   filehandle to write to
# 
# For example,
#   print_fh(\*IN, \*OUT)
# 
# This is equivalent to while (<IN>) { print OUT }, but faster.
# 
sub print_fh($$) {
    die 'usage: print_fh(input fh, output fh)' if @_ != 2;
    my ($in, $out) = @_;
    local $_;
    until (eof $in) {
	read($in, $_, $BUFSIZE)
	  or die 'error reading from filehandle, or undetected eof';
	print $out $_;
    }
}


# is_tex_error()
# 
# An attempt to guess whether a line of TeX output or logfile is an
# error message.  But this is almost impossible, so we catch only
# serious errors, those beginning with '!', '*!', '**!', etc.
# 
sub is_tex_error($) {
    die 'usage: is_tex_error(line of output from tex)' if @_ != 1;
    local $_ = shift;
    /^\**!/;
}

